{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar NavigationActions = _interopRequireWildcard(require(\"../NavigationActions\"));\nvar StackActions = _interopRequireWildcard(require(\"./StackActions\"));\nvar _createConfigGetter = _interopRequireDefault(require(\"./createConfigGetter\"));\nvar _getScreenForRouteName = _interopRequireDefault(require(\"./getScreenForRouteName\"));\nvar _StateUtils = _interopRequireDefault(require(\"../StateUtils\"));\nvar _validateRouteConfigMap = _interopRequireDefault(require(\"./validateRouteConfigMap\"));\nvar _invariant = _interopRequireDefault(require(\"../utils/invariant\"));\nvar _KeyGenerator = require(\"./KeyGenerator\");\nvar _pathUtils = require(\"./pathUtils\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction behavesLikePushAction(action) {\n  return action.type === NavigationActions.NAVIGATE || action.type === StackActions.PUSH;\n}\nvar defaultActionCreators = function defaultActionCreators() {\n  return {};\n};\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\nvar _default = function _default(routeConfigs) {\n  var stackConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0, _validateRouteConfigMap.default)(routeConfigs);\n  var childRouters = {};\n  var routeNames = Object.keys(routeConfigs);\n  routeNames.forEach(function (routeName) {\n    var routeConfig = routeConfigs[routeName];\n    var screen = routeConfig && routeConfig.screen ? routeConfig.screen : routeConfig;\n    if (screen && screen.router) {\n      childRouters[routeName] = screen.router;\n    } else {\n      childRouters[routeName] = null;\n    }\n  });\n  var initialRouteParams = stackConfig.initialRouteParams;\n  var getCustomActionCreators = stackConfig.getCustomActionCreators || defaultActionCreators;\n  var initialRouteName = stackConfig.initialRouteName || routeNames[0];\n  var initialChildRouter = childRouters[initialRouteName];\n  function getInitialState(action) {\n    var route = {};\n    var childRouter = childRouters[action.routeName];\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      var childState = {};\n      if (childRouter !== null) {\n        var childAction = action.action || NavigationActions.init({\n          params: action.params\n        });\n        childState = childRouter.getStateForAction(childAction);\n      }\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [_objectSpread(_objectSpread({\n          params: action.params\n        }, childState), {}, {\n          key: action.key || (0, _KeyGenerator.generateKey)(),\n          routeName: action.routeName\n        })]\n      };\n    }\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(NavigationActions.navigate({\n        routeName: initialRouteName,\n        params: initialRouteParams\n      }));\n    }\n    var params = (routeConfigs[initialRouteName].params || route.params || action.params || initialRouteParams) && _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, routeConfigs[initialRouteName].params || {}), route.params || {}), action.params || {}), initialRouteParams || {});\n    var initialRouteKey = stackConfig.initialRouteKey;\n    route = _objectSpread(_objectSpread(_objectSpread({}, route), params ? {\n      params: params\n    } : {}), {}, {\n      routeName: initialRouteName,\n      key: action.key || initialRouteKey || (0, _KeyGenerator.generateKey)()\n    });\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route]\n    };\n  }\n  function getParamsForRouteAndAction(routeName, action) {\n    var routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return _objectSpread(_objectSpread({}, routeConfig.params), action.params);\n    } else {\n      return action.params;\n    }\n  }\n  var _createPathParser = (0, _pathUtils.createPathParser)(childRouters, routeConfigs, stackConfig),\n    getPathAndParamsForRoute = _createPathParser.getPathAndParamsForRoute,\n    _getActionForPathAndParams = _createPathParser.getActionForPathAndParams;\n  return {\n    childRouters: childRouters,\n    getComponentForState: function getComponentForState(state) {\n      var activeChildRoute = state.routes[state.index];\n      var routeName = activeChildRoute.routeName;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return (0, _getScreenForRouteName.default)(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return (0, _getScreenForRouteName.default)(routeConfigs, routeName);\n    },\n    getActionCreators: function getActionCreators(route, navStateKey) {\n      return _objectSpread(_objectSpread({}, getCustomActionCreators(route, navStateKey)), {}, {\n        pop: function pop(n, params) {\n          return StackActions.pop(_objectSpread({\n            n: n\n          }, params));\n        },\n        popToTop: function popToTop(params) {\n          return StackActions.popToTop(params);\n        },\n        push: function push(routeName, params, action) {\n          return StackActions.push({\n            routeName: routeName,\n            params: params,\n            action: action\n          });\n        },\n        replace: function replace(replaceWith, params, action, newKey) {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params: params,\n              action: action,\n              key: route.key,\n              newKey: newKey\n            });\n          }\n          (0, _invariant.default)(typeof replaceWith === 'object', 'Must replaceWith an object or a string');\n          (0, _invariant.default)(params == null, 'Params must not be provided to .replace() when specifying an object');\n          (0, _invariant.default)(action == null, 'Child action must not be provided to .replace() when specifying an object');\n          (0, _invariant.default)(newKey == null, 'Child action must not be provided to .replace() when specifying an object');\n          return StackActions.replace(replaceWith);\n        },\n        reset: function reset(actions, index) {\n          return StackActions.reset({\n            actions: actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey\n          });\n        },\n        dismiss: function dismiss() {\n          return NavigationActions.back({\n            key: navStateKey\n          });\n        }\n      });\n    },\n    getStateForAction: function getStateForAction(action, state) {\n      if (!state) {\n        return getInitialState(action);\n      }\n      var activeChildRoute = state.routes[state.index];\n      if (!isResetToRootStack(action) && action.type !== NavigationActions.NAVIGATE) {\n        var activeChildRouter = childRouters[activeChildRoute.routeName];\n        if (activeChildRouter) {\n          var route = activeChildRouter.getStateForAction(action, activeChildRoute);\n          if (route !== null && route !== activeChildRoute) {\n            return _StateUtils.default.replaceAt(state, activeChildRoute.key, route, action.type === NavigationActions.SET_PARAMS);\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        for (var _iterator = _createForOfIteratorHelperLoose(state.routes.slice().reverse()), _step; !(_step = _iterator()).done;) {\n          var childRoute = _step.value;\n          var childRouter = childRouters[childRoute.routeName];\n          var childAction = action.routeName === childRoute.routeName && action.action ? action.action : action;\n          if (childRouter) {\n            var nextRouteState = childRouter.getStateForAction(childAction, childRoute);\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              var newState = _StateUtils.default.replaceAndPrune(state, nextRouteState ? nextRouteState.key : childRoute.key, nextRouteState ? nextRouteState : childRoute);\n              return _objectSpread(_objectSpread({}, newState), {}, {\n                isTransitioning: state.index !== newState.index ? action.immediate !== true : state.isTransitioning\n              });\n            }\n          }\n        }\n      }\n      if (behavesLikePushAction(action) && childRouters[action.routeName] !== undefined) {\n        var _childRouter = childRouters[action.routeName];\n        var _route;\n        (0, _invariant.default)(action.type !== StackActions.PUSH || action.key == null, 'StackRouter does not support key on the push action');\n        var lastRouteIndex = state.routes.findIndex(function (r) {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n          var routes = state.routes.slice(0, lastRouteIndex + 1);\n          if (action.params) {\n            var _route2 = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = _objectSpread(_objectSpread({}, _route2), {}, {\n              params: _objectSpread(_objectSpread({}, _route2.params), action.params)\n            });\n          }\n          return _objectSpread(_objectSpread({}, state), {}, {\n            isTransitioning: state.index !== lastRouteIndex ? action.immediate !== true : state.isTransitioning,\n            index: lastRouteIndex,\n            routes: routes\n          });\n        }\n        if (_childRouter) {\n          var _childAction = action.action || NavigationActions.init({\n            params: getParamsForRouteAndAction(action.routeName, action)\n          });\n          _route = _objectSpread(_objectSpread({\n            params: getParamsForRouteAndAction(action.routeName, action)\n          }, _childRouter.getStateForAction(_childAction)), {}, {\n            routeName: action.routeName,\n            key: action.key || (0, _KeyGenerator.generateKey)()\n          });\n        } else {\n          _route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            routeName: action.routeName,\n            key: action.key || (0, _KeyGenerator.generateKey)()\n          };\n        }\n        return _objectSpread(_objectSpread({}, _StateUtils.default.push(state, _route)), {}, {\n          isTransitioning: action.immediate !== true\n        });\n      } else if (action.type === StackActions.PUSH && childRouters[action.routeName] === undefined) {\n        return state;\n      }\n      if (behavesLikePushAction(action)) {\n        var childRouterNames = Object.keys(childRouters);\n        for (var i = 0; i < childRouterNames.length; i++) {\n          var childRouterName = childRouterNames[i];\n          var _childRouter2 = childRouters[childRouterName];\n          if (_childRouter2) {\n            var initChildRoute = _childRouter2.getStateForAction(NavigationActions.init());\n            var navigatedChildRoute = _childRouter2.getStateForAction(action, initChildRoute);\n            var routeToPush = null;\n            if (navigatedChildRoute === null) {\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              var _route3 = _objectSpread(_objectSpread({}, routeToPush), {}, {\n                routeName: childRouterName,\n                key: action.key || (0, _KeyGenerator.generateKey)()\n              });\n              return _objectSpread(_objectSpread({}, _StateUtils.default.push(state, _route3)), {}, {\n                isTransitioning: action.immediate !== true\n              });\n            }\n          }\n        }\n      }\n      if (action.type === StackActions.POP_TO_TOP) {\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n        if (state.index > 0) {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]]\n          });\n        }\n        return state;\n      }\n      if (action.type === StackActions.REPLACE) {\n        var routeIndex;\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex(function (r) {\n            return r.key === action.key;\n          });\n        }\n        if (routeIndex !== -1) {\n          var _childRouter3 = childRouters[action.routeName];\n          var childState = {};\n          if (_childRouter3) {\n            var _childAction2 = action.action || NavigationActions.init({\n              params: getParamsForRouteAndAction(action.routeName, action)\n            });\n            childState = _childRouter3.getStateForAction(_childAction2);\n          }\n          var _routes = (0, _toConsumableArray2.default)(state.routes);\n          _routes[routeIndex] = _objectSpread(_objectSpread({\n            params: getParamsForRouteAndAction(action.routeName, action)\n          }, childState), {}, {\n            routeName: action.routeName,\n            key: action.newKey || (0, _KeyGenerator.generateKey)()\n          });\n          return _objectSpread(_objectSpread({}, state), {}, {\n            routes: _routes\n          });\n        }\n      }\n      if (action.type === StackActions.COMPLETE_TRANSITION && (action.key == null || action.key === state.key) && action.toChildKey === state.routes[state.index].key && state.isTransitioning) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          isTransitioning: false\n        });\n      }\n      if (action.type === NavigationActions.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n        if (lastRoute) {\n          var params = _objectSpread(_objectSpread({}, lastRoute.params), action.params);\n          var _routes2 = (0, _toConsumableArray2.default)(state.routes);\n          _routes2[state.routes.indexOf(lastRoute)] = _objectSpread(_objectSpread({}, lastRoute), {}, {\n            params: params\n          });\n          return _objectSpread(_objectSpread({}, state), {}, {\n            routes: _routes2\n          });\n        }\n      }\n      if (action.type === StackActions.RESET) {\n        if (action.key != null && action.key !== state.key) {\n          return state;\n        }\n        var newStackActions = action.actions;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          routes: newStackActions.map(function (newStackAction) {\n            var router = childRouters[newStackAction.routeName];\n            var childState = {};\n            if (router) {\n              var _childAction3 = newStackAction.action || NavigationActions.init({\n                params: getParamsForRouteAndAction(newStackAction.routeName, newStackAction)\n              });\n              childState = router.getStateForAction(_childAction3);\n            }\n            return _objectSpread(_objectSpread({\n              params: getParamsForRouteAndAction(newStackAction.routeName, newStackAction)\n            }, childState), {}, {\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || (0, _KeyGenerator.generateKey)()\n            });\n          }),\n          index: action.index\n        });\n      }\n      if (action.type === NavigationActions.BACK || action.type === StackActions.POP) {\n        var _key = action.key,\n          n = action.n,\n          immediate = action.immediate,\n          prune = action.prune;\n        if (action.type === StackActions.POP && prune === false && _key) {\n          var index = state.routes.findIndex(function (r) {\n            return r.key === _key;\n          });\n          if (index > 0) {\n            var count = Math.max(index - (n !== null && n !== void 0 ? n : 1) + 1, 1);\n            var _routes3 = state.routes.slice(0, count).concat(state.routes.slice(index + 1));\n            if (_routes3.length) {\n              return _objectSpread(_objectSpread({}, state), {}, {\n                routes: _routes3,\n                index: _routes3.length - 1,\n                isTransitioning: immediate !== true\n              });\n            }\n          }\n        } else {\n          var backRouteIndex = state.index;\n          if (action.type === StackActions.POP && n != null) {\n            backRouteIndex = Math.max(1, state.index - n + 1);\n          } else if (_key) {\n            var backRoute = state.routes.find(function (route) {\n              return route.key === _key;\n            });\n            backRouteIndex = state.routes.indexOf(backRoute);\n          }\n          if (backRouteIndex > 0) {\n            return _objectSpread(_objectSpread({}, state), {}, {\n              routes: state.routes.slice(0, backRouteIndex),\n              index: backRouteIndex - 1,\n              isTransitioning: immediate !== true\n            });\n          }\n        }\n      }\n      var keyIndex = action.key ? _StateUtils.default.indexOf(state, action.key) : -1;\n      for (var _iterator2 = _createForOfIteratorHelperLoose(state.routes.slice().reverse()), _step2; !(_step2 = _iterator2()).done;) {\n        var _childRoute = _step2.value;\n        if (_childRoute.key === activeChildRoute.key) {\n          continue;\n        }\n        if (keyIndex >= 0 && _childRoute.key !== action.key) {\n          continue;\n        }\n        var _childRouter4 = childRouters[_childRoute.routeName];\n        if (_childRouter4) {\n          var _route4 = _childRouter4.getStateForAction(action, _childRoute);\n          if (_route4 === null) {\n            return state;\n          } else if (_route4 && _route4 !== _childRoute) {\n            return _StateUtils.default.replaceAt(state, _childRoute.key, _route4, action.preserveFocus || action.type.includes('DRAWER'));\n          }\n        }\n      }\n      return state;\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(path, params) {\n      return _getActionForPathAndParams(path, params);\n    },\n    getScreenOptions: (0, _createConfigGetter.default)(routeConfigs, stackConfig.defaultNavigationOptions)\n  };\n};\nexports.default = _default;","map":{"version":3,"names":["NavigationActions","_interopRequireWildcard","require","StackActions","_createConfigGetter","_interopRequireDefault","_getScreenForRouteName","_StateUtils","_validateRouteConfigMap","_invariant","_KeyGenerator","_pathUtils","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_createForOfIteratorHelperLoose","o","allowArrayLike","it","Symbol","iterator","next","bind","Array","isArray","_unsupportedIterableToArray","length","i","done","value","TypeError","minLen","_arrayLikeToArray","n","toString","slice","constructor","name","from","test","arr","len","arr2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","_defineProperty2","getOwnPropertyDescriptors","defineProperties","behavesLikePushAction","action","type","NAVIGATE","PUSH","defaultActionCreators","isResetToRootStack","RESET","_default","routeConfigs","stackConfig","undefined","validateRouteConfigMap","childRouters","routeNames","routeName","routeConfig","screen","router","initialRouteParams","getCustomActionCreators","initialRouteName","initialChildRouter","getInitialState","route","childRouter","childState","childAction","init","params","getStateForAction","isTransitioning","index","routes","generateKey","navigate","initialRouteKey","getParamsForRouteAndAction","_createPathParser","createPathParser","getPathAndParamsForRoute","getActionForPathAndParams","getComponentForState","state","activeChildRoute","getScreenForRouteName","getComponentForRouteName","getActionCreators","navStateKey","pop","popToTop","replace","replaceWith","newKey","invariant","reset","actions","dismiss","back","activeChildRouter","StateUtils","replaceAt","SET_PARAMS","_iterator","reverse","_step","childRoute","nextRouteState","newState","replaceAndPrune","immediate","lastRouteIndex","findIndex","r","childRouterNames","childRouterName","initChildRoute","navigatedChildRoute","routeToPush","POP_TO_TOP","REPLACE","routeIndex","_toConsumableArray2","COMPLETE_TRANSITION","toChildKey","lastRoute","find","indexOf","newStackActions","map","newStackAction","BACK","POP","prune","count","Math","max","concat","backRouteIndex","backRoute","keyIndex","_iterator2","_step2","preserveFocus","includes","getPathAndParamsForState","path","getScreenOptions","createConfigGetter","defaultNavigationOptions","exports"],"sources":["C:\\xampp\\htdocs\\Kush\\whatsapp_facebook_messenger\\chat\\node_modules\\@react-navigation\\core\\lib\\module\\routers\\StackRouter.js"],"sourcesContent":["import * as NavigationActions from '../NavigationActions';\nimport * as StackActions from './StackActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport invariant from '../utils/invariant';\nimport { generateKey } from './KeyGenerator';\nimport { createPathParser } from './pathUtils';\n\nfunction behavesLikePushAction(action) {\n  return (\n    action.type === NavigationActions.NAVIGATE ||\n    action.type === StackActions.PUSH\n  );\n}\n\nconst defaultActionCreators = () => ({});\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default (routeConfigs, stackConfig = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs);\n\n  // Loop through routes and find child routers\n  routeNames.forEach((routeName) => {\n    // We're not using `getScreenForRouteName` here to preserve the lazy loading\n    // behaviour of routes. This means that routes with child routers must be\n    // defined using a component directly or with an object with a screen prop.\n    const routeConfig = routeConfigs[routeName];\n    const screen =\n      routeConfig && routeConfig.screen ? routeConfig.screen : routeConfig;\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n\n  const { initialRouteParams } = stackConfig;\n  const getCustomActionCreators =\n    stackConfig.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n\n  const initialChildRouter = childRouters[initialRouteName];\n\n  function getInitialState(action) {\n    let route = {};\n    const childRouter = childRouters[action.routeName];\n\n    // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      let childState = {};\n      // The router is null for normal leaf routes\n      if (childRouter !== null) {\n        const childAction =\n          action.action || NavigationActions.init({ params: action.params });\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [\n          {\n            params: action.params,\n            ...childState,\n            key: action.key || generateKey(),\n            routeName: action.routeName,\n          },\n        ],\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(\n        NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: initialRouteParams,\n        })\n      );\n    }\n    const params = (routeConfigs[initialRouteName].params ||\n      route.params ||\n      action.params ||\n      initialRouteParams) && {\n      ...(routeConfigs[initialRouteName].params || {}),\n      ...(route.params || {}),\n      ...(action.params || {}),\n      ...(initialRouteParams || {}),\n    };\n    const { initialRouteKey } = stackConfig;\n    route = {\n      ...route,\n      ...(params ? { params } : {}),\n      routeName: initialRouteName,\n      key: action.key || initialRouteKey || generateKey(),\n    };\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route],\n    };\n  }\n\n  function getParamsForRouteAndAction(routeName, action) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...action.params };\n    } else {\n      return action.params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, stackConfig);\n\n  return {\n    childRouters,\n\n    getComponentForState(state) {\n      const activeChildRoute = state.routes[state.index];\n      const { routeName } = activeChildRoute;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getActionCreators(route, navStateKey) {\n      return {\n        ...getCustomActionCreators(route, navStateKey),\n        pop: (n, params) =>\n          StackActions.pop({\n            n,\n            ...params,\n          }),\n        popToTop: (params) => StackActions.popToTop(params),\n        push: (routeName, params, action) =>\n          StackActions.push({\n            routeName,\n            params,\n            action,\n          }),\n        replace: (replaceWith, params, action, newKey) => {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params,\n              action,\n              key: route.key,\n              newKey,\n            });\n          }\n          invariant(\n            typeof replaceWith === 'object',\n            'Must replaceWith an object or a string'\n          );\n          invariant(\n            params == null,\n            'Params must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            action == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            newKey == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          return StackActions.replace(replaceWith);\n        },\n        reset: (actions, index) =>\n          StackActions.reset({\n            actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey,\n          }),\n        dismiss: () =>\n          NavigationActions.back({\n            key: navStateKey,\n          }),\n      };\n    },\n\n    getStateForAction(action, state) {\n      // Set up the initial state if needed\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      const activeChildRoute = state.routes[state.index];\n\n      if (\n        !isResetToRootStack(action) &&\n        action.type !== NavigationActions.NAVIGATE\n      ) {\n        // Let the active child router handle the action\n        const activeChildRouter = childRouters[activeChildRoute.routeName];\n        if (activeChildRouter) {\n          const route = activeChildRouter.getStateForAction(\n            action,\n            activeChildRoute\n          );\n          if (route !== null && route !== activeChildRoute) {\n            return StateUtils.replaceAt(\n              state,\n              activeChildRoute.key,\n              route,\n              // the following tells replaceAt to NOT change the index to this route for the setParam action, because people don't expect param-setting actions to switch the active route\n              action.type === NavigationActions.SET_PARAMS\n            );\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        // Traverse routes from the top of the stack to the bottom, so the\n        // active route has the first opportunity, then the one before it, etc.\n\n        for (let childRoute of state.routes.slice().reverse()) {\n          let childRouter = childRouters[childRoute.routeName];\n          let childAction =\n            action.routeName === childRoute.routeName && action.action\n              ? action.action\n              : action;\n\n          if (childRouter) {\n            const nextRouteState = childRouter.getStateForAction(\n              childAction,\n              childRoute\n            );\n\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              const newState = StateUtils.replaceAndPrune(\n                state,\n                nextRouteState ? nextRouteState.key : childRoute.key,\n                nextRouteState ? nextRouteState : childRoute\n              );\n              return {\n                ...newState,\n                isTransitioning:\n                  state.index !== newState.index\n                    ? action.immediate !== true\n                    : state.isTransitioning,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle push and navigate actions. This must happen after the focused\n      // child router has had a chance to handle the action.\n      if (\n        behavesLikePushAction(action) &&\n        childRouters[action.routeName] !== undefined // undefined means it's not a childRouter or a screen\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n\n        invariant(\n          action.type !== StackActions.PUSH || action.key == null,\n          'StackRouter does not support key on the push action'\n        );\n\n        // Before pushing a new route we first try to find one in the existing route stack\n        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md\n        const lastRouteIndex = state.routes.findIndex((r) => {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        // An instance of this route exists already and we're dealing with a navigate action\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          // If index is unchanged and params are not being set, leave state identity intact\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n\n          // Remove the now unused routes at the tail of the routes array\n          const routes = state.routes.slice(0, lastRouteIndex + 1);\n\n          // Apply params if provided, otherwise leave route identity intact\n          if (action.params) {\n            const route = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = {\n              ...route,\n              params: {\n                ...route.params,\n                ...action.params,\n              },\n            };\n          }\n          // Return state with new index. Change isTransitioning only if index has changed\n          return {\n            ...state,\n            isTransitioning:\n              state.index !== lastRouteIndex\n                ? action.immediate !== true\n                : state.isTransitioning,\n            index: lastRouteIndex,\n            routes,\n          };\n        }\n\n        if (childRouter) {\n          // Delegate to the child router with the given action, or init it\n          const childAction =\n            action.action ||\n            NavigationActions.init({\n              params: getParamsForRouteAndAction(action.routeName, action),\n            });\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // note(brentvatne): does it make sense to wipe out the params\n            // here? or even to add params at all? need more info about what\n            // this solves\n            ...childRouter.getStateForAction(childAction),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        } else {\n          // Create the route from scratch\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        }\n        return {\n          ...StateUtils.push(state, route),\n          isTransitioning: action.immediate !== true,\n        };\n      } else if (\n        action.type === StackActions.PUSH &&\n        childRouters[action.routeName] === undefined\n      ) {\n        // Return the state identity to bubble the action up\n        return state;\n      }\n\n      // Handle navigation to other child routers that are not yet pushed\n      if (behavesLikePushAction(action)) {\n        const childRouterNames = Object.keys(childRouters);\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(\n              NavigationActions.init()\n            );\n            // Then check to see if the router handles our navigate action\n            const navigatedChildRoute = childRouter.getStateForAction(\n              action,\n              initChildRoute\n            );\n            let routeToPush = null;\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              const route = {\n                ...routeToPush,\n                routeName: childRouterName,\n                key: action.key || generateKey(),\n              };\n              return {\n                ...StateUtils.push(state, route),\n                isTransitioning: action.immediate !== true,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\n      if (action.type === StackActions.POP_TO_TOP) {\n        // Refuse to handle pop to top if a key is given that doesn't correspond\n        // to this router\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        // If we're already at the top, then we return the state with a new\n        // identity so that the action is handled by this router.\n        if (state.index > 0) {\n          return {\n            ...state,\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]],\n          };\n        }\n        return state;\n      }\n\n      // Handle replace action\n      if (action.type === StackActions.REPLACE) {\n        let routeIndex;\n\n        // If the key param is undefined, set the index to the last route in the stack\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex((r) => r.key === action.key);\n        }\n\n        // Only replace if the key matches one of our routes\n        if (routeIndex !== -1) {\n          const childRouter = childRouters[action.routeName];\n          let childState = {};\n          if (childRouter) {\n            const childAction =\n              action.action ||\n              NavigationActions.init({\n                params: getParamsForRouteAndAction(action.routeName, action),\n              });\n            childState = childRouter.getStateForAction(childAction);\n          }\n          const routes = [...state.routes];\n          routes[routeIndex] = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // merge the child state in this order to allow params override\n            ...childState,\n            routeName: action.routeName,\n            key: action.newKey || generateKey(),\n          };\n          return { ...state, routes };\n        }\n      }\n\n      // Update transitioning state\n      if (\n        action.type === StackActions.COMPLETE_TRANSITION &&\n        (action.key == null || action.key === state.key) &&\n        action.toChildKey === state.routes[state.index].key &&\n        state.isTransitioning\n      ) {\n        return {\n          ...state,\n          isTransitioning: false,\n        };\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find((route) => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        // Only handle reset actions that are unspecified or match this state key\n        if (action.key != null && action.key !== state.key) {\n          // Deliberately use != instead of !== so we can match null with\n          // undefined on either the state or the action\n          return state;\n        }\n        const newStackActions = action.actions;\n\n        return {\n          ...state,\n          routes: newStackActions.map((newStackAction) => {\n            const router = childRouters[newStackAction.routeName];\n\n            let childState = {};\n\n            if (router) {\n              const childAction =\n                newStackAction.action ||\n                NavigationActions.init({\n                  params: getParamsForRouteAndAction(\n                    newStackAction.routeName,\n                    newStackAction\n                  ),\n                });\n\n              childState = router.getStateForAction(childAction);\n            }\n\n            return {\n              params: getParamsForRouteAndAction(\n                newStackAction.routeName,\n                newStackAction\n              ),\n              ...childState,\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey(),\n            };\n          }),\n          index: action.index,\n        };\n      }\n\n      if (\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP\n      ) {\n        const { key, n, immediate, prune } = action;\n\n        if (action.type === StackActions.POP && prune === false && key) {\n          const index = state.routes.findIndex((r) => r.key === key);\n\n          if (index > 0) {\n            const count = Math.max(index - (n ?? 1) + 1, 1);\n            const routes = state.routes\n              .slice(0, count)\n              .concat(state.routes.slice(index + 1));\n\n            if (routes.length) {\n              return {\n                ...state,\n                routes,\n                index: routes.length - 1,\n                isTransitioning: immediate !== true,\n              };\n            }\n          }\n        } else {\n          let backRouteIndex = state.index;\n\n          if (action.type === StackActions.POP && n != null) {\n            // determine the index to go back *from*. In this case, n=1 means to go\n            // back from state.index, as if it were a normal \"BACK\" action\n            backRouteIndex = Math.max(1, state.index - n + 1);\n          } else if (key) {\n            const backRoute = state.routes.find((route) => route.key === key);\n            backRouteIndex = state.routes.indexOf(backRoute);\n          }\n\n          if (backRouteIndex > 0) {\n            return {\n              ...state,\n              routes: state.routes.slice(0, backRouteIndex),\n              index: backRouteIndex - 1,\n              isTransitioning: immediate !== true,\n            };\n          }\n        }\n      }\n\n      // By this point in the router's state handling logic, we have handled the behavior of the active route, and handled any stack actions.\n      // If we haven't returned by now, we should allow non-active child routers to handle this action, and switch to that index if the child state (route) does change..\n\n      const keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\n\n      // Traverse routes from the top of the stack to the bottom, so the\n      // active route has the first opportunity, then the one before it, etc.\n      for (let childRoute of state.routes.slice().reverse()) {\n        if (childRoute.key === activeChildRoute.key) {\n          // skip over the active child because we let it attempt to handle the action earlier\n          continue;\n        }\n        // If a key is provided and in routes state then let's use that\n        // knowledge to skip extra getStateForAction calls on other child\n        // routers\n        if (keyIndex >= 0 && childRoute.key !== action.key) {\n          continue;\n        }\n        let childRouter = childRouters[childRoute.routeName];\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n\n          if (route === null) {\n            return state;\n          } else if (route && route !== childRoute) {\n            return StateUtils.replaceAt(\n              state,\n              childRoute.key,\n              route,\n              // People don't expect these actions to switch the active route\n              // TODO: We should switch to action.preserveFocus: true for drawer in future\n              action.preserveFocus || action.type.includes('DRAWER')\n            );\n          }\n        }\n      }\n\n      return state;\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      stackConfig.defaultNavigationOptions\n    ),\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}