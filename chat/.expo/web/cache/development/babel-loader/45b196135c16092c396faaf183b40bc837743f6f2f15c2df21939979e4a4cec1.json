{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _State = require(\"../../State\");\nvar _interfaces = require(\"../interfaces\");\nvar _PointerTracker = _interopRequireDefault(require(\"./PointerTracker\"));\nvar _utils = require(\"../utils\");\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar GestureHandlerOrchestrator = function () {\n  function GestureHandlerOrchestrator() {\n    (0, _classCallCheck2.default)(this, GestureHandlerOrchestrator);\n    _defineProperty(this, \"gestureHandlers\", []);\n    _defineProperty(this, \"awaitingHandlers\", []);\n    _defineProperty(this, \"handlersToCancel\", []);\n    _defineProperty(this, \"handlingChangeSemaphore\", 0);\n    _defineProperty(this, \"activationIndex\", 0);\n  }\n  (0, _createClass2.default)(GestureHandlerOrchestrator, [{\n    key: \"scheduleFinishedHandlersCleanup\",\n    value: function scheduleFinishedHandlersCleanup() {\n      if (this.handlingChangeSemaphore === 0) {\n        this.cleanupFinishedHandlers();\n      }\n    }\n  }, {\n    key: \"cleanHandler\",\n    value: function cleanHandler(handler) {\n      handler.reset();\n      handler.setActive(false);\n      handler.setAwaiting(false);\n      handler.setActivationIndex(Number.MAX_VALUE);\n    }\n  }, {\n    key: \"removeHandlerFromOrchestrator\",\n    value: function removeHandlerFromOrchestrator(handler) {\n      this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n      this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n      this.handlersToCancel.splice(this.handlersToCancel.indexOf(handler), 1);\n    }\n  }, {\n    key: \"cleanupFinishedHandlers\",\n    value: function cleanupFinishedHandlers() {\n      for (var i = this.gestureHandlers.length - 1; i >= 0; --i) {\n        var handler = this.gestureHandlers[i];\n        if (!handler) {\n          continue;\n        }\n        if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n          this.gestureHandlers.splice(i, 1);\n          this.cleanHandler(handler);\n        }\n      }\n    }\n  }, {\n    key: \"hasOtherHandlerToWaitFor\",\n    value: function hasOtherHandlerToWaitFor(handler) {\n      var _this = this;\n      var hasToWait = false;\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (otherHandler && !_this.isFinished(otherHandler.getState()) && _this.shouldHandlerWaitForOther(handler, otherHandler)) {\n          hasToWait = true;\n          return;\n        }\n      });\n      return hasToWait;\n    }\n  }, {\n    key: \"tryActivate\",\n    value: function tryActivate(handler) {\n      if (this.hasOtherHandlerToWaitFor(handler)) {\n        this.addAwaitingHandler(handler);\n      } else if (handler.getState() !== _State.State.CANCELLED && handler.getState() !== _State.State.FAILED) {\n        if (this.shouldActivate(handler)) {\n          this.makeActive(handler);\n        } else {\n          switch (handler.getState()) {\n            case _State.State.ACTIVE:\n              handler.fail();\n              break;\n            case _State.State.BEGAN:\n              handler.cancel();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"shouldActivate\",\n    value: function shouldActivate(handler) {\n      for (var _iterator = _createForOfIteratorHelperLoose(this.gestureHandlers), _step; !(_step = _iterator()).done;) {\n        var otherHandler = _step.value;\n        if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"cleanupAwaitingHandlers\",\n    value: function cleanupAwaitingHandlers(handler) {\n      for (var i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (!this.awaitingHandlers[i].isAwaiting() && this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)) {\n          this.cleanHandler(this.awaitingHandlers[i]);\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n  }, {\n    key: \"onHandlerStateChange\",\n    value: function onHandlerStateChange(handler, newState, oldState, sendIfDisabled) {\n      var _this2 = this;\n      if (!handler.isEnabled() && !sendIfDisabled) {\n        return;\n      }\n      this.handlingChangeSemaphore += 1;\n      if (this.isFinished(newState)) {\n        this.awaitingHandlers.forEach(function (otherHandler) {\n          if (_this2.shouldHandlerWaitForOther(otherHandler, handler)) {\n            if (newState === _State.State.END) {\n              otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.cancel();\n              if (otherHandler.getState() === _State.State.END) {\n                otherHandler.sendEvent(_State.State.CANCELLED, _State.State.BEGAN);\n              }\n              otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.setAwaiting(false);\n            } else {\n              _this2.tryActivate(otherHandler);\n            }\n          }\n        });\n      }\n      if (newState === _State.State.ACTIVE) {\n        this.tryActivate(handler);\n      } else if (oldState === _State.State.ACTIVE || oldState === _State.State.END) {\n        if (handler.isActive()) {\n          handler.sendEvent(newState, oldState);\n        } else if (oldState === _State.State.ACTIVE && (newState === _State.State.CANCELLED || newState === _State.State.FAILED)) {\n          handler.sendEvent(newState, _State.State.BEGAN);\n        }\n      } else if (oldState !== _State.State.UNDETERMINED || newState !== _State.State.CANCELLED) {\n        handler.sendEvent(newState, oldState);\n      }\n      this.handlingChangeSemaphore -= 1;\n      this.scheduleFinishedHandlersCleanup();\n      if (this.awaitingHandlers.indexOf(handler) < 0) {\n        this.cleanupAwaitingHandlers(handler);\n      }\n    }\n  }, {\n    key: \"makeActive\",\n    value: function makeActive(handler) {\n      var _this3 = this;\n      var currentState = handler.getState();\n      handler.setActive(true);\n      handler.setShouldResetProgress(true);\n      handler.setActivationIndex(this.activationIndex++);\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (_this3.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n          _this3.handlersToCancel.push(otherHandler);\n        }\n      });\n      for (var i = this.handlersToCancel.length - 1; i >= 0; --i) {\n        var _this$handlersToCance;\n        (_this$handlersToCance = this.handlersToCancel[i]) === null || _this$handlersToCance === void 0 ? void 0 : _this$handlersToCance.cancel();\n      }\n      this.awaitingHandlers.forEach(function (otherHandler) {\n        if (_this3.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n          otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.cancel();\n          otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.setAwaiting(true);\n        }\n      });\n      handler.sendEvent(_State.State.ACTIVE, _State.State.BEGAN);\n      if (currentState !== _State.State.ACTIVE) {\n        handler.sendEvent(_State.State.END, _State.State.ACTIVE);\n        if (currentState !== _State.State.END) {\n          handler.sendEvent(_State.State.UNDETERMINED, _State.State.END);\n        }\n      }\n      if (handler.isAwaiting()) {\n        handler.setAwaiting(false);\n        for (var _i = 0; _i < this.awaitingHandlers.length; ++_i) {\n          if (this.awaitingHandlers[_i] === handler) {\n            this.awaitingHandlers.splice(_i, 1);\n          }\n        }\n      }\n      this.handlersToCancel = [];\n    }\n  }, {\n    key: \"addAwaitingHandler\",\n    value: function addAwaitingHandler(handler) {\n      var alreadyExists = false;\n      this.awaitingHandlers.forEach(function (otherHandler) {\n        if (otherHandler === handler) {\n          alreadyExists = true;\n          return;\n        }\n      });\n      if (alreadyExists) {\n        return;\n      }\n      this.awaitingHandlers.push(handler);\n      handler.setAwaiting(true);\n      handler.setActivationIndex(this.activationIndex++);\n    }\n  }, {\n    key: \"recordHandlerIfNotPresent\",\n    value: function recordHandlerIfNotPresent(handler) {\n      var alreadyExists = false;\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (otherHandler === handler) {\n          alreadyExists = true;\n          return;\n        }\n      });\n      if (alreadyExists) {\n        return;\n      }\n      this.gestureHandlers.push(handler);\n      handler.setActive(false);\n      handler.setAwaiting(false);\n      handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n    }\n  }, {\n    key: \"shouldHandlerWaitForOther\",\n    value: function shouldHandlerWaitForOther(handler, otherHandler) {\n      return handler !== otherHandler && (handler.shouldWaitForHandlerFailure(otherHandler) || otherHandler.shouldRequireToWaitForFailure(handler));\n    }\n  }, {\n    key: \"canRunSimultaneously\",\n    value: function canRunSimultaneously(gh1, gh2) {\n      return gh1 === gh2 || gh1.shouldRecognizeSimultaneously(gh2) || gh2.shouldRecognizeSimultaneously(gh1);\n    }\n  }, {\n    key: \"shouldHandlerBeCancelledBy\",\n    value: function shouldHandlerBeCancelledBy(handler, otherHandler) {\n      if (this.canRunSimultaneously(handler, otherHandler)) {\n        return false;\n      }\n      if (handler !== otherHandler && (handler.isAwaiting() || handler.getState() === _State.State.ACTIVE)) {\n        return handler.shouldBeCancelledByOther(otherHandler);\n      }\n      var handlerPointers = handler.getTrackedPointersID();\n      var otherPointers = otherHandler.getTrackedPointersID();\n      if (!_PointerTracker.default.shareCommonPointers(handlerPointers, otherPointers) && handler.getView() !== otherHandler.getView()) {\n        return this.checkOverlap(handler, otherHandler);\n      }\n      return true;\n    }\n  }, {\n    key: \"checkOverlap\",\n    value: function checkOverlap(handler, otherHandler) {\n      var handlerPointers = handler.getTrackedPointersID();\n      var otherPointers = otherHandler.getTrackedPointersID();\n      var overlap = false;\n      handlerPointers.forEach(function (pointer) {\n        var handlerX = handler.getTracker().getLastX(pointer);\n        var handlerY = handler.getTracker().getLastY(pointer);\n        if ((0, _utils.isPointerInBounds)(handler.getView(), {\n          x: handlerX,\n          y: handlerY\n        }) && (0, _utils.isPointerInBounds)(otherHandler.getView(), {\n          x: handlerX,\n          y: handlerY\n        })) {\n          overlap = true;\n        }\n      });\n      otherPointers.forEach(function (pointer) {\n        var otherX = otherHandler.getTracker().getLastX(pointer);\n        var otherY = otherHandler.getTracker().getLastY(pointer);\n        if ((0, _utils.isPointerInBounds)(handler.getView(), {\n          x: otherX,\n          y: otherY\n        }) && (0, _utils.isPointerInBounds)(otherHandler.getView(), {\n          x: otherX,\n          y: otherY\n        })) {\n          overlap = true;\n        }\n      });\n      return overlap;\n    }\n  }, {\n    key: \"isFinished\",\n    value: function isFinished(state) {\n      return state === _State.State.END || state === _State.State.FAILED || state === _State.State.CANCELLED;\n    }\n  }, {\n    key: \"cancelMouseAndPenGestures\",\n    value: function cancelMouseAndPenGestures(currentHandler) {\n      this.gestureHandlers.forEach(function (handler) {\n        if (handler.getPointerType() !== _interfaces.PointerType.MOUSE && handler.getPointerType() !== _interfaces.PointerType.PEN) {\n          return;\n        }\n        if (handler !== currentHandler) {\n          handler.cancel();\n        } else {\n          handler.getTracker().resetTracker();\n        }\n      });\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!GestureHandlerOrchestrator.instance) {\n        GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n      }\n      return GestureHandlerOrchestrator.instance;\n    }\n  }]);\n  return GestureHandlerOrchestrator;\n}();\nexports.default = GestureHandlerOrchestrator;\n_defineProperty(GestureHandlerOrchestrator, \"instance\", void 0);","map":{"version":3,"names":["_State","require","_interfaces","_PointerTracker","_interopRequireDefault","_utils","_createForOfIteratorHelperLoose","o","allowArrayLike","it","Symbol","iterator","call","next","bind","Array","isArray","_unsupportedIterableToArray","length","i","done","value","TypeError","minLen","_arrayLikeToArray","n","Object","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","GestureHandlerOrchestrator","_classCallCheck2","default","_defineProperty","_createClass2","key","scheduleFinishedHandlersCleanup","handlingChangeSemaphore","cleanupFinishedHandlers","cleanHandler","handler","reset","setActive","setAwaiting","setActivationIndex","Number","MAX_VALUE","removeHandlerFromOrchestrator","gestureHandlers","splice","indexOf","awaitingHandlers","handlersToCancel","isFinished","getState","isAwaiting","hasOtherHandlerToWaitFor","_this","hasToWait","forEach","otherHandler","shouldHandlerWaitForOther","tryActivate","addAwaitingHandler","State","CANCELLED","FAILED","shouldActivate","makeActive","ACTIVE","fail","BEGAN","cancel","_iterator","_step","shouldHandlerBeCancelledBy","cleanupAwaitingHandlers","onHandlerStateChange","newState","oldState","sendIfDisabled","_this2","isEnabled","END","sendEvent","isActive","UNDETERMINED","_this3","currentState","setShouldResetProgress","activationIndex","push","_this$handlersToCance","alreadyExists","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","shouldBeCancelledByOther","handlerPointers","getTrackedPointersID","otherPointers","PointerTracker","shareCommonPointers","getView","checkOverlap","overlap","pointer","handlerX","getTracker","getLastX","handlerY","getLastY","isPointerInBounds","x","y","otherX","otherY","state","cancelMouseAndPenGestures","currentHandler","getPointerType","PointerType","MOUSE","PEN","resetTracker","getInstance","instance","exports"],"sources":["C:\\xampp\\htdocs\\Kush\\whatsapp_facebook_messenger\\chat\\node_modules\\react-native-gesture-handler\\lib\\module\\web\\tools\\GestureHandlerOrchestrator.ts"],"sourcesContent":["import { State } from '../../State';\nimport { PointerType } from '../interfaces';\n\nimport GestureHandler from '../handlers/GestureHandler';\nimport PointerTracker from './PointerTracker';\nimport { isPointerInBounds } from '../utils';\n\nexport default class GestureHandlerOrchestrator {\n  private static instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: GestureHandler[] = [];\n  private awaitingHandlers: GestureHandler[] = [];\n  private handlersToCancel: GestureHandler[] = [];\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: GestureHandler): void {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n\n  public removeHandlerFromOrchestrator(handler: GestureHandler): void {\n    this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n    this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n    this.handlersToCancel.splice(this.handlersToCancel.indexOf(handler), 1);\n  }\n\n  private cleanupFinishedHandlers(): void {\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (!handler) {\n        continue;\n      }\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.gestureHandlers.splice(i, 1);\n\n        this.cleanHandler(handler);\n      }\n    }\n  }\n\n  private hasOtherHandlerToWaitFor(handler: GestureHandler): boolean {\n    let hasToWait = false;\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (\n        otherHandler &&\n        !this.isFinished(otherHandler.getState()) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      ) {\n        hasToWait = true;\n        return;\n      }\n    });\n\n    return hasToWait;\n  }\n\n  private tryActivate(handler: GestureHandler): void {\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n    } else if (\n      handler.getState() !== State.CANCELLED &&\n      handler.getState() !== State.FAILED\n    ) {\n      if (this.shouldActivate(handler)) {\n        this.makeActive(handler);\n      } else {\n        switch (handler.getState()) {\n          case State.ACTIVE:\n            handler.fail();\n            break;\n          case State.BEGAN:\n            handler.cancel();\n        }\n      }\n    }\n  }\n\n  private shouldActivate(handler: GestureHandler): boolean {\n    for (const otherHandler of this.gestureHandlers) {\n      if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private cleanupAwaitingHandlers(handler: GestureHandler): void {\n    for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n      if (\n        !this.awaitingHandlers[i].isAwaiting() &&\n        this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)\n      ) {\n        this.cleanHandler(this.awaitingHandlers[i]);\n        this.awaitingHandlers.splice(i, 1);\n      }\n    }\n  }\n\n  public onHandlerStateChange(\n    handler: GestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.isEnabled() && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      this.awaitingHandlers.forEach((otherHandler) => {\n        if (this.shouldHandlerWaitForOther(otherHandler, handler)) {\n          if (newState === State.END) {\n            otherHandler?.cancel();\n            if (otherHandler.getState() === State.END) {\n              // Handle edge case, where discrete gestures end immediately after activation thus\n              // their state is set to END and when the gesture they are waiting for activates they\n              // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n              // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n              otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n            }\n            otherHandler?.setAwaiting(false);\n          } else {\n            this.tryActivate(otherHandler);\n          }\n        }\n      });\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (this.awaitingHandlers.indexOf(handler) < 0) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: GestureHandler): void {\n    const currentState = handler.getState();\n\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      // Order of arguments is correct - we check whether current handler should cancel existing handlers\n\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        this.handlersToCancel.push(otherHandler);\n      }\n    });\n\n    for (let i = this.handlersToCancel.length - 1; i >= 0; --i) {\n      this.handlersToCancel[i]?.cancel();\n    }\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler?.cancel();\n        otherHandler?.setAwaiting(true);\n      }\n    });\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (handler.isAwaiting()) {\n      handler.setAwaiting(false);\n      for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (this.awaitingHandlers[i] === handler) {\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n\n    this.handlersToCancel = [];\n  }\n\n  private addAwaitingHandler(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n\n  public recordHandlerIfNotPresent(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: GestureHandler,\n    gh2: GestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (\n      handler !== otherHandler &&\n      (handler.isAwaiting() || handler.getState() === State.ACTIVE)\n    ) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.getView() !== otherHandler.getView()\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    let overlap = false;\n\n    handlerPointers.forEach((pointer: number) => {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: handlerX, y: handlerY }) &&\n        isPointerInBounds(otherHandler.getView(), { x: handlerX, y: handlerY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    otherPointers.forEach((pointer: number) => {\n      const otherX: number = otherHandler.getTracker().getLastX(pointer);\n      const otherY: number = otherHandler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: otherX, y: otherY }) &&\n        isPointerInBounds(otherHandler.getView(), { x: otherX, y: otherY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    return overlap;\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: GestureHandler): void {\n    this.gestureHandlers.forEach((handler: GestureHandler) => {\n      if (\n        handler.getPointerType() !== PointerType.MOUSE &&\n        handler.getPointerType() !== PointerType.PEN\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}