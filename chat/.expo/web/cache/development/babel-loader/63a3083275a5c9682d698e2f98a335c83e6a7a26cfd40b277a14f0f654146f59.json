{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _reactNative = require(\"react-native\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar KeyboardManager = function (_React$Component) {\n  (0, _inherits2.default)(KeyboardManager, _React$Component);\n  var _super = _createSuper(KeyboardManager);\n  function KeyboardManager() {\n    var _this;\n    (0, _classCallCheck2.default)(this, KeyboardManager);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"previouslyFocusedTextInput\", undefined);\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"startTimestamp\", 0);\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"keyboardTimeout\", void 0);\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"clearKeyboardTimeout\", function () {\n      if (_this.keyboardTimeout !== undefined) {\n        clearTimeout(_this.keyboardTimeout);\n        _this.keyboardTimeout = undefined;\n      }\n    });\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"handlePageChangeStart\", function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n      _this.clearKeyboardTimeout();\n      var input = _reactNative.TextInput.State.currentlyFocusedInput ? _reactNative.TextInput.State.currentlyFocusedInput() : _reactNative.TextInput.State.currentlyFocusedField();\n      _reactNative.TextInput.State.blurTextInput(input);\n      _this.previouslyFocusedTextInput = input;\n      _this.startTimestamp = Date.now();\n    });\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"handlePageChangeConfirm\", function (force) {\n      if (!_this.props.enabled) {\n        return;\n      }\n      _this.clearKeyboardTimeout();\n      if (force) {\n        _reactNative.Keyboard.dismiss();\n      } else {\n        var input = _this.previouslyFocusedTextInput;\n        if (input) {\n          _reactNative.TextInput.State.blurTextInput(input);\n        }\n      }\n      _this.previouslyFocusedTextInput = undefined;\n    });\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"handlePageChangeCancel\", function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n      _this.clearKeyboardTimeout();\n      var input = _this.previouslyFocusedTextInput;\n      if (input) {\n        if (Date.now() - _this.startTimestamp < 100) {\n          _this.keyboardTimeout = setTimeout(function () {\n            _reactNative.TextInput.State.focusTextInput(input);\n            _this.previouslyFocusedTextInput = undefined;\n          }, 100);\n        } else {\n          _reactNative.TextInput.State.focusTextInput(input);\n          _this.previouslyFocusedTextInput = undefined;\n        }\n      }\n    });\n    return _this;\n  }\n  (0, _createClass2.default)(KeyboardManager, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearKeyboardTimeout();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.props.children({\n        onPageChangeStart: this.handlePageChangeStart,\n        onPageChangeConfirm: this.handlePageChangeConfirm,\n        onPageChangeCancel: this.handlePageChangeCancel\n      });\n    }\n  }]);\n  return KeyboardManager;\n}(React.Component);\nexports.default = KeyboardManager;","map":{"version":3,"names":["React","_interopRequireWildcard","require","_reactNative","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","_getPrototypeOf2","result","NewTarget","constructor","Reflect","construct","arguments","apply","_possibleConstructorReturn2","sham","Proxy","Boolean","valueOf","e","KeyboardManager","_React$Component","_inherits2","_super","_this","_classCallCheck2","_len","length","args","Array","_key","concat","_defineProperty","_assertThisInitialized2","undefined","keyboardTimeout","clearTimeout","props","enabled","clearKeyboardTimeout","input","TextInput","State","currentlyFocusedInput","currentlyFocusedField","blurTextInput","previouslyFocusedTextInput","startTimestamp","Date","now","force","Keyboard","dismiss","setTimeout","focusTextInput","_createClass2","value","componentWillUnmount","render","children","onPageChangeStart","handlePageChangeStart","onPageChangeConfirm","handlePageChangeConfirm","onPageChangeCancel","handlePageChangeCancel","Component","exports"],"sources":["C:\\xampp\\htdocs\\Kush\\whatsapp_facebook_messenger\\chat\\node_modules\\@react-navigation\\stack\\lib\\module\\views\\KeyboardManager.tsx"],"sourcesContent":["import * as React from 'react';\nimport { TextInput, Keyboard, HostComponent } from 'react-native';\n\ntype Props = {\n  enabled: boolean;\n  children: (props: {\n    onPageChangeStart: () => void;\n    onPageChangeConfirm: (force: boolean) => void;\n    onPageChangeCancel: () => void;\n  }) => React.ReactNode;\n};\n\ntype InputRef = React.ElementRef<HostComponent<unknown>> | undefined;\n\nexport default class KeyboardManager extends React.Component<Props> {\n  componentWillUnmount() {\n    this.clearKeyboardTimeout();\n  }\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: InputRef = undefined;\n  private startTimestamp: number = 0;\n  private keyboardTimeout: any;\n\n  private clearKeyboardTimeout = () => {\n    if (this.keyboardTimeout !== undefined) {\n      clearTimeout(this.keyboardTimeout);\n      this.keyboardTimeout = undefined;\n    }\n  };\n\n  private handlePageChangeStart = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // @ts-expect-error: blurTextInput accepts both number and ref, but types say only ref\n    const input: InputRef = TextInput.State.currentlyFocusedInput\n      ? TextInput.State.currentlyFocusedInput()\n      : TextInput.State.currentlyFocusedField();\n\n    // When a page change begins, blur the currently focused input\n    TextInput.State.blurTextInput(input);\n\n    // Store the id of this input so we can refocus it if change was cancelled\n    this.previouslyFocusedTextInput = input;\n\n    // Store timestamp for touch start\n    this.startTimestamp = Date.now();\n  };\n\n  private handlePageChangeConfirm = (force: boolean) => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    if (force) {\n      // Always dismiss input, even if we don't have a ref to it\n      // We might not have the ref if onPageChangeStart was never called\n      // This can happen if page change was not from a gesture\n      Keyboard.dismiss();\n    } else {\n      const input = this.previouslyFocusedTextInput;\n\n      if (input) {\n        // Dismiss the keyboard only if an input was a focused before\n        // This makes sure we don't dismiss input on going back and focusing an input\n        TextInput.State.blurTextInput(input);\n      }\n    }\n\n    // Cleanup the ID on successful page change\n    this.previouslyFocusedTextInput = undefined;\n  };\n\n  private handlePageChangeCancel = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // The page didn't change, we should restore the focus of text input\n    const input = this.previouslyFocusedTextInput;\n\n    if (input) {\n      // If the interaction was super short we should make sure keyboard won't hide again.\n\n      // Too fast input refocus will result only in keyboard flashing on screen and hiding right away.\n      // During first ~100ms keyboard will be dismissed no matter what,\n      // so we have to make sure it won't interrupt input refocus logic.\n      // That's why when the interaction is shorter than 100ms we add delay so it won't hide once again.\n      // Subtracting timestamps makes us sure the delay is executed only when needed.\n      if (Date.now() - this.startTimestamp < 100) {\n        this.keyboardTimeout = setTimeout(() => {\n          TextInput.State.focusTextInput(input);\n          this.previouslyFocusedTextInput = undefined;\n        }, 100);\n      } else {\n        TextInput.State.focusTextInput(input);\n        this.previouslyFocusedTextInput = undefined;\n      }\n    }\n  };\n\n  render() {\n    return this.props.children({\n      onPageChangeStart: this.handlePageChangeStart,\n      onPageChangeConfirm: this.handlePageChangeConfirm,\n      onPageChangeCancel: this.handlePageChangeCancel,\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}