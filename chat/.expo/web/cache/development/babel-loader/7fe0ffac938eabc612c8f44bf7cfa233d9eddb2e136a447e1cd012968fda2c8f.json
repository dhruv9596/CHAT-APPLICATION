{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getPathFromState;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar queryString = _interopRequireWildcard(require(\"query-string\"));\nvar _checkLegacyPathConfig = _interopRequireDefault(require(\"./checkLegacyPathConfig\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar getActiveRoute = function getActiveRoute(state) {\n  var route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n  return route;\n};\nfunction getPathFromState(state, options) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n  var _checkLegacyPathConfi = (0, _checkLegacyPathConfig.default)(options),\n    _checkLegacyPathConfi2 = (0, _slicedToArray2.default)(_checkLegacyPathConfi, 2),\n    legacy = _checkLegacyPathConfi2[0],\n    compatOptions = _checkLegacyPathConfi2[1];\n  var configs = compatOptions ? createNormalizedConfigs(legacy, compatOptions.screens) : {};\n  var path = '/';\n  var current = state;\n  var allParams = {};\n  var _loop = function _loop() {\n    var index = typeof current.index === 'number' ? current.index : 0;\n    var route = current.routes[index];\n    var pattern;\n    var focusedParams;\n    var focusedRoute = getActiveRoute(state);\n    var currentOptions = configs;\n    var nestedRouteNames = [];\n    var hasNext = true;\n    var _loop2 = function _loop2() {\n      pattern = currentOptions[route.name].pattern;\n      nestedRouteNames.push(route.name);\n      if (route.params) {\n        var stringify = (_currentOptions$route = currentOptions[route.name]) === null || _currentOptions$route === void 0 ? void 0 : _currentOptions$route.stringify;\n        var currentParams = fromEntries(Object.entries(route.params).map(function (_ref) {\n          var _ref2 = (0, _slicedToArray2.default)(_ref, 2),\n            key = _ref2[0],\n            value = _ref2[1];\n          return [key, stringify !== null && stringify !== void 0 && stringify[key] ? stringify[key](value) : String(value)];\n        }));\n        if (pattern) {\n          (0, _extends2.default)(allParams, currentParams);\n        }\n        if (focusedRoute === route) {\n          focusedParams = _objectSpread({}, currentParams);\n          (_pattern = pattern) === null || _pattern === void 0 ? void 0 : _pattern.split('/').filter(function (p) {\n            return p.startsWith(':');\n          }).forEach(function (p) {\n            var name = getParamName(p);\n            if (focusedParams) {\n              delete focusedParams[name];\n            }\n          });\n        }\n      }\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        var nextRoute = route.state.routes[index];\n        var nestedConfig = currentOptions[route.name].screens;\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          hasNext = false;\n        }\n      }\n    };\n    while (route.name in currentOptions && hasNext) {\n      _loop2();\n    }\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern.split('/').map(function (p) {\n        var name = getParamName(p);\n        if (p === '*') {\n          if (legacy) {\n            throw new Error(\"Please update your config to the new format to use wildcard pattern ('*'). https://reactnavigation.org/docs/5.x/configuring-links/#updating-config\");\n          }\n          return route.name;\n        }\n        if (p.startsWith(':')) {\n          var value = allParams[name];\n          if (value === undefined && p.endsWith('?')) {\n            return '';\n          }\n          return encodeURIComponent(value);\n        }\n        return encodeURIComponent(p);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (var param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          delete focusedParams[param];\n        }\n      }\n      var query = queryString.stringify(focusedParams);\n      if (query) {\n        path += \"?\".concat(query);\n      }\n    }\n    current = route.state;\n  };\n  while (current) {\n    var _currentOptions$route, _pattern;\n    _loop();\n  }\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n  return path;\n}\nvar fromEntries = function fromEntries(entries) {\n  return entries.reduce(function (acc, _ref3) {\n    var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),\n      k = _ref4[0],\n      v = _ref4[1];\n    if (acc.hasOwnProperty(k)) {\n      throw new Error(\"A value for key '\".concat(k, \"' already exists in the object.\"));\n    }\n    acc[k] = v;\n    return acc;\n  }, {});\n};\nvar getParamName = function getParamName(pattern) {\n  return pattern.replace(/^:/, '').replace(/\\?$/, '');\n};\nvar joinPaths = function joinPaths() {\n  var _ref5;\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n  return (_ref5 = []).concat.apply(_ref5, (0, _toConsumableArray2.default)(paths.map(function (p) {\n    return p.split('/');\n  }))).filter(Boolean).join('/');\n};\nvar createConfigItem = function createConfigItem(legacy, config, parentPattern) {\n  var _pattern2;\n  if (typeof config === 'string') {\n    var _pattern3 = parentPattern ? joinPaths(parentPattern, config) : config;\n    return {\n      pattern: _pattern3\n    };\n  }\n  var pattern;\n  if (legacy) {\n    pattern = config.exact !== true && parentPattern && config.path ? joinPaths(parentPattern, config.path) : config.path;\n  } else {\n    if (config.exact && config.path === undefined) {\n      throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n    }\n    pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n  }\n  var screens = config.screens ? createNormalizedConfigs(legacy, config.screens, pattern) : undefined;\n  return {\n    pattern: (_pattern2 = pattern) === null || _pattern2 === void 0 ? void 0 : _pattern2.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens: screens\n  };\n};\nvar createNormalizedConfigs = function createNormalizedConfigs(legacy, options, pattern) {\n  return fromEntries(Object.entries(options).map(function (_ref6) {\n    var _ref7 = (0, _slicedToArray2.default)(_ref6, 2),\n      name = _ref7[0],\n      c = _ref7[1];\n    var result = createConfigItem(legacy, c, pattern);\n    return [name, result];\n  }));\n};","map":{"version":3,"names":["queryString","_interopRequireWildcard","require","_checkLegacyPathConfig","_interopRequireDefault","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","_defineProperty2","getOwnPropertyDescriptors","defineProperties","getActiveRoute","state","route","index","routes","getPathFromState","options","Error","_checkLegacyPathConfi","checkLegacyPathConfig","_checkLegacyPathConfi2","_slicedToArray2","legacy","compatOptions","configs","createNormalizedConfigs","screens","path","current","allParams","_loop","pattern","focusedParams","focusedRoute","currentOptions","nestedRouteNames","hasNext","_loop2","name","params","stringify","_currentOptions$route","currentParams","fromEntries","entries","map","_ref","_ref2","value","String","_extends2","_pattern","split","p","startsWith","getParamName","undefined","nextRoute","nestedConfig","join","endsWith","encodeURIComponent","param","query","concat","replace","reduce","acc","_ref3","_ref4","k","v","joinPaths","_ref5","_len","paths","Array","_key","_toConsumableArray2","Boolean","createConfigItem","config","parentPattern","_pattern2","exact","_ref6","_ref7","c","result"],"sources":["C:\\xampp\\htdocs\\Kush\\whatsapp_facebook_messenger\\chat\\node_modules\\@react-navigation\\native\\node_modules\\@react-navigation\\core\\lib\\module\\getPathFromState.tsx"],"sourcesContent":["import * as queryString from 'query-string';\nimport type {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport checkLegacyPathConfig from './checkLegacyPathConfig';\nimport type { PathConfig, PathConfigMap } from './types';\n\ntype Options = { initialRouteName?: string; screens: PathConfigMap };\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState(\n  state: State,\n  options?: Options\n): string {\n  if (state == null) {\n    throw Error(\n      \"Got 'undefined' for the navigation state. You must pass a valid state object.\"\n    );\n  }\n\n  const [legacy, compatOptions] = checkLegacyPathConfig(options);\n\n  // Create a normalized configs object which will be easier to use\n  const configs: Record<string, ConfigItem> = compatOptions\n    ? createNormalizedConfigs(legacy, compatOptions.screens)\n    : {};\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let pattern: string | undefined;\n\n    let focusedParams: Record<string, any> | undefined;\n    let focusedRoute = getActiveRoute(state);\n    let currentOptions = configs;\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    let nestedRouteNames = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n\n        const currentParams = fromEntries(\n          Object.entries(route.params).map(([key, value]) => [\n            key,\n            stringify?.[key] ? stringify[key](value) : String(value),\n          ])\n        );\n\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n\n        if (focusedRoute === route) {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = { ...currentParams };\n\n          pattern\n            ?.split('/')\n            .filter((p) => p.startsWith(':'))\n            // eslint-disable-next-line no-loop-func\n            .forEach((p) => {\n              const name = getParamName(p);\n\n              // Remove the params present in the pattern since we'll only use the rest for query string\n              if (focusedParams) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete focusedParams[name];\n              }\n            });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number'\n            ? route.state.index\n            : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern\n        .split('/')\n        .map((p) => {\n          const name = getParamName(p);\n\n          // We don't know what to show for wildcard patterns\n          // Showing the route name seems ok, though whatever we show here will be incorrect\n          // Since the page doesn't actually exist\n          if (p === '*') {\n            if (legacy) {\n              throw new Error(\n                \"Please update your config to the new format to use wildcard pattern ('*'). https://reactnavigation.org/docs/5.x/configuring-links/#updating-config\"\n              );\n            }\n\n            return route.name;\n          }\n\n          // If the path has a pattern for a param, put the param in the path\n          if (p.startsWith(':')) {\n            const value = allParams[name];\n\n            if (value === undefined && p.endsWith('?')) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            return encodeURIComponent(value);\n          }\n\n          return encodeURIComponent(p);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (let param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n\n      const query = queryString.stringify(focusedParams);\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  return path;\n}\n\n// Object.fromEntries is not available in older iOS versions\nconst fromEntries = <K extends string, V>(entries: (readonly [K, V])[]) =>\n  entries.reduce((acc, [k, v]) => {\n    if (acc.hasOwnProperty(k)) {\n      throw new Error(`A value for key '${k}' already exists in the object.`);\n    }\n\n    acc[k] = v;\n    return acc;\n  }, {} as Record<K, V>);\n\nconst getParamName = (pattern: string) =>\n  pattern.replace(/^:/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  legacy: boolean,\n  config: PathConfig | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  let pattern: string | undefined;\n\n  if (legacy) {\n    pattern =\n      config.exact !== true && parentPattern && config.path\n        ? joinPaths(parentPattern, config.path)\n        : config.path;\n  } else {\n    if (config.exact && config.path === undefined) {\n      throw new Error(\n        \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n      );\n    }\n\n    pattern =\n      config.exact !== true\n        ? joinPaths(parentPattern || '', config.path || '')\n        : config.path || '';\n  }\n\n  const screens = config.screens\n    ? createNormalizedConfigs(legacy, config.screens, pattern)\n    : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n  };\n};\n\nconst createNormalizedConfigs = (\n  legacy: boolean,\n  options: PathConfigMap,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(legacy, c, pattern);\n\n      return [name, result];\n    })\n  );\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}