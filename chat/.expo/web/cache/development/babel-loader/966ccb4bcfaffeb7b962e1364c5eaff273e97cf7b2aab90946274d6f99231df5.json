{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\nvar _invariant = _interopRequireDefault(require(\"../utils/invariant\"));\nvar _getScreenForRouteName = _interopRequireDefault(require(\"./getScreenForRouteName\"));\nvar _createConfigGetter = _interopRequireDefault(require(\"./createConfigGetter\"));\nvar NavigationActions = _interopRequireWildcard(require(\"../NavigationActions\"));\nvar SwitchActions = _interopRequireWildcard(require(\"./SwitchActions\"));\nvar StackActions = _interopRequireWildcard(require(\"./StackActions\"));\nvar _validateRouteConfigMap = _interopRequireDefault(require(\"./validateRouteConfigMap\"));\nvar _pathUtils = require(\"./pathUtils\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar defaultActionCreators = function defaultActionCreators() {\n  return {};\n};\nvar _default = function _default(routeConfigs) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0, _validateRouteConfigMap.default)(routeConfigs);\n  var order = config.order || Object.keys(routeConfigs);\n  var getCustomActionCreators = config.getCustomActionCreators || defaultActionCreators;\n  var initialRouteParams = config.initialRouteParams;\n  var initialRouteName = config.initialRouteName || order[0];\n  var backBehavior = config.backBehavior || 'none';\n  var resetOnBlur = config.hasOwnProperty('resetOnBlur') ? config.resetOnBlur : true;\n  var initialRouteIndex = order.indexOf(initialRouteName);\n  if (initialRouteIndex === -1) {\n    throw new Error(\"Invalid initialRouteName '\".concat(initialRouteName, \"'.\") + \"Should be one of \".concat(order.map(function (n) {\n      return \"\\\"\".concat(n, \"\\\"\");\n    }).join(', ')));\n  }\n  var childRouters = {};\n  order.forEach(function (routeName) {\n    childRouters[routeName] = null;\n    var screen = (0, _getScreenForRouteName.default)(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n  function getParamsForRoute(routeName, params) {\n    var routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return _objectSpread(_objectSpread({}, routeConfig.params), params);\n    } else {\n      return params;\n    }\n  }\n  var _createPathParser = (0, _pathUtils.createPathParser)(childRouters, routeConfigs, config),\n    getPathAndParamsForRoute = _createPathParser.getPathAndParamsForRoute,\n    _getActionForPathAndParams = _createPathParser.getActionForPathAndParams;\n  function resetChildRoute(routeName) {\n    var initialParams = routeName === initialRouteName ? initialRouteParams : null;\n    var params = getParamsForRoute(routeName, initialParams);\n    var childRouter = childRouters[routeName];\n    if (childRouter) {\n      var childAction = NavigationActions.init();\n      return _objectSpread(_objectSpread({}, childRouter.getStateForAction(childAction)), {}, {\n        key: routeName,\n        routeName: routeName\n      }, params ? {\n        params: params\n      } : {});\n    }\n    return _objectSpread({\n      key: routeName,\n      routeName: routeName\n    }, params ? {\n      params: params\n    } : {});\n  }\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(prevState, nextState) {\n      if (backBehavior !== 'history' || prevState && nextState && nextState.index === prevState.index) {\n        return nextState;\n      }\n      var nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = (0, _toConsumableArray2.default)(nextRouteKeyHistory);\n        var keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(function (k) {\n          return k !== keyToAdd;\n        });\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = (0, _toConsumableArray2.default)(nextRouteKeyHistory);\n        nextRouteKeyHistory.pop();\n      }\n      return _objectSpread(_objectSpread({}, nextState), {}, {\n        routeKeyHistory: nextRouteKeyHistory\n      });\n    }\n    var nextState = possibleNextState;\n    if (prevState && possibleNextState && prevState.index !== possibleNextState.index && resetOnBlur) {\n      var prevRouteName = prevState.routes[prevState.index].routeName;\n      var nextRoutes = (0, _toConsumableArray2.default)(possibleNextState.routes);\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = _objectSpread(_objectSpread({}, possibleNextState), {}, {\n        routes: nextRoutes\n      });\n    }\n    return updateNextStateHistory(prevState, nextState);\n  }\n  function getInitialState() {\n    var routes = order.map(resetChildRoute);\n    var initialState = {\n      routes: routes,\n      index: initialRouteIndex\n    };\n    if (backBehavior === 'history') {\n      var initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n    return initialState;\n  }\n  return {\n    childRouters: childRouters,\n    getActionCreators: function getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n    getStateForAction: function getStateForAction(action, inputState) {\n      var prevState = inputState ? _objectSpread({}, inputState) : inputState;\n      var state = inputState || getInitialState();\n      var activeChildIndex = state.index;\n      if (action.type === NavigationActions.INIT) {\n        var params = action.params;\n        if (params) {\n          state.routes = state.routes.map(function (route) {\n            return _objectSpread(_objectSpread({}, route), {}, {\n              params: _objectSpread(_objectSpread(_objectSpread({}, route.params), params), route.routeName === initialRouteName ? initialRouteParams : null)\n            });\n          });\n        }\n      }\n      if (action.type === SwitchActions.JUMP_TO && (action.key == null || action.key === state.key)) {\n        var _params = action.params;\n        var index = state.routes.findIndex(function (route) {\n          return route.routeName === action.routeName;\n        });\n        if (index === -1) {\n          throw new Error(\"There is no route named '\".concat(action.routeName, \"' in the navigator with the key '\").concat(action.key, \"'.\\n\") + \"Must be one of: \".concat(state.routes.map(function (route) {\n            return \"'\".concat(route.routeName, \"'\");\n          }).join(',')));\n        }\n        return getNextState(action, prevState, _objectSpread(_objectSpread({}, state), {}, {\n          routes: _params ? state.routes.map(function (route, i) {\n            return i === index ? _objectSpread(_objectSpread({}, route), {}, {\n              params: _objectSpread(_objectSpread({}, route.params), _params)\n            }) : route;\n          }) : state.routes,\n          index: index\n        }));\n      }\n      var activeChildLastState = state.routes[state.index];\n      var activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        var activeChildState = activeChildRouter.getStateForAction(action, activeChildLastState);\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          var routes = (0, _toConsumableArray2.default)(state.routes);\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, _objectSpread(_objectSpread({}, state), {}, {\n            routes: routes\n          }));\n        }\n      }\n      var isBackEligible = action.key == null || action.key === activeChildLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        } else if (isBackEligible && backBehavior === 'history' && state.routeKeyHistory.length > 1) {\n          var routeKey = state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        }\n      }\n      var didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find(function (childId, i) {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          var childState = state.routes[activeChildIndex];\n          var childRouter = childRouters[action.routeName];\n          var newChildState = childState;\n          if (action.action && childRouter) {\n            var childStateUpdate = childRouter.getStateForAction(action.action, childState);\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n          if (action.params) {\n            newChildState = _objectSpread(_objectSpread({}, newChildState), {}, {\n              params: _objectSpread(_objectSpread({}, newChildState.params || {}), action.params)\n            });\n          }\n          if (newChildState !== childState) {\n            var _routes = (0, _toConsumableArray2.default)(state.routes);\n            _routes[activeChildIndex] = newChildState;\n            var nextState = _objectSpread(_objectSpread({}, state), {}, {\n              routes: _routes,\n              index: activeChildIndex\n            });\n            return getNextState(action, prevState, nextState);\n          } else if (newChildState === childState && state.index === activeChildIndex && prevState) {\n            return null;\n          }\n        }\n      }\n      if (action.type === NavigationActions.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n        if (lastRoute) {\n          var _params2 = _objectSpread(_objectSpread({}, lastRoute.params), action.params);\n          var _routes2 = (0, _toConsumableArray2.default)(state.routes);\n          _routes2[state.routes.indexOf(lastRoute)] = _objectSpread(_objectSpread({}, lastRoute), {}, {\n            params: _params2\n          });\n          return getNextState(action, prevState, _objectSpread(_objectSpread({}, state), {}, {\n            routes: _routes2\n          }));\n        }\n      }\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, _objectSpread(_objectSpread({}, state), {}, {\n          index: activeChildIndex\n        }));\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return _objectSpread({}, state);\n      }\n      var isActionBackOrPop = action.type === NavigationActions.BACK || action.type === StackActions.POP || action.type === StackActions.POP_TO_TOP;\n      var sendActionToInactiveChildren = !isActionBackOrPop || action.type === NavigationActions.BACK && action.key != null;\n      if (sendActionToInactiveChildren) {\n        var _index = state.index;\n        var _routes3 = state.routes;\n        order.find(function (childId, i) {\n          var childRouter = childRouters[childId];\n          if (i === _index) {\n            return false;\n          }\n          var childState = _routes3[i];\n          if (childRouter) {\n            childState = childRouter.getStateForAction(action, childState);\n          }\n          if (!childState) {\n            _index = i;\n            return true;\n          }\n          if (childState !== _routes3[i]) {\n            _routes3 = (0, _toConsumableArray2.default)(_routes3);\n            _routes3[i] = childState;\n            _index = i;\n            return true;\n          }\n          return false;\n        });\n        if (action.preserveFocus) {\n          _index = state.index;\n        }\n        if (_index !== state.index || _routes3 !== state.routes) {\n          return getNextState(action, prevState, _objectSpread(_objectSpread({}, state), {}, {\n            index: _index,\n            routes: _routes3\n          }));\n        }\n      }\n      return state;\n    },\n    getComponentForState: function getComponentForState(state) {\n      var routeName = state.routes[state.index].routeName;\n      (0, _invariant.default)(routeName, \"There is no route defined for index \".concat(state.index, \". Check that\\n        that you passed in a navigation state with a valid tab/screen index.\"));\n      var childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return (0, _getScreenForRouteName.default)(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return (0, _getScreenForRouteName.default)(routeConfigs, routeName);\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(path, params) {\n      return _getActionForPathAndParams(path, params);\n    },\n    getScreenOptions: (0, _createConfigGetter.default)(routeConfigs, config.defaultNavigationOptions)\n  };\n};\nexports.default = _default;","map":{"version":3,"names":["_invariant","_interopRequireDefault","require","_getScreenForRouteName","_createConfigGetter","NavigationActions","_interopRequireWildcard","SwitchActions","StackActions","_validateRouteConfigMap","_pathUtils","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","_defineProperty2","getOwnPropertyDescriptors","defineProperties","defaultActionCreators","_default","routeConfigs","config","undefined","validateRouteConfigMap","order","getCustomActionCreators","initialRouteParams","initialRouteName","backBehavior","resetOnBlur","initialRouteIndex","indexOf","Error","concat","map","n","join","childRouters","routeName","screen","getScreenForRouteName","router","getParamsForRoute","params","routeConfig","_createPathParser","createPathParser","getPathAndParamsForRoute","getActionForPathAndParams","resetChildRoute","initialParams","childRouter","childAction","init","getStateForAction","getNextState","action","prevState","possibleNextState","updateNextStateHistory","nextState","index","nextRouteKeyHistory","routeKeyHistory","type","NAVIGATE","_toConsumableArray2","keyToAdd","routes","k","BACK","pop","prevRouteName","nextRoutes","getInitialState","initialState","initialKey","getActionCreators","route","stateKey","inputState","state","activeChildIndex","INIT","JUMP_TO","findIndex","activeChildLastState","activeChildRouter","activeChildState","isBackEligible","Math","max","routeKey","didNavigate","find","childId","childState","newChildState","childStateUpdate","SET_PARAMS","lastRoute","isActionBackOrPop","POP","POP_TO_TOP","sendActionToInactiveChildren","preserveFocus","getComponentForState","invariant","getComponentForRouteName","getPathAndParamsForState","path","getScreenOptions","createConfigGetter","defaultNavigationOptions","exports"],"sources":["C:\\xampp\\htdocs\\Kush\\whatsapp_facebook_messenger\\chat\\node_modules\\@react-navigation\\core\\lib\\module\\routers\\SwitchRouter.js"],"sourcesContent":["import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport * as NavigationActions from '../NavigationActions';\nimport * as SwitchActions from './SwitchActions';\nimport * as StackActions from './StackActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport { createPathParser } from './pathUtils';\n\nconst defaultActionCreators = () => ({});\n\nexport default (routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n\n  const getCustomActionCreators =\n    config.getCustomActionCreators || defaultActionCreators;\n\n  const { initialRouteParams } = config;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur')\n    ? config.resetOnBlur\n    : true;\n\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  if (initialRouteIndex === -1) {\n    throw new Error(\n      `Invalid initialRouteName '${initialRouteName}'.` +\n        `Should be one of ${order.map((n) => `\"${n}\"`).join(', ')}`\n    );\n  }\n\n  const childRouters = {};\n  order.forEach((routeName) => {\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...params };\n    } else {\n      return params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, config);\n\n  function resetChildRoute(routeName) {\n    let initialParams =\n      routeName === initialRouteName ? initialRouteParams : null;\n    // note(brentvatne): merging initialRouteParams *on top* of default params\n    // on the route seems incorrect but it's consistent with existing behavior\n    // in stackrouter\n    let params = getParamsForRoute(routeName, initialParams);\n    const childRouter = childRouters[routeName];\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return {\n        ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        ...(params ? { params } : {}),\n      };\n    }\n    return {\n      key: routeName,\n      routeName,\n      ...(params ? { params } : {}),\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(prevState, nextState) {\n      if (\n        backBehavior !== 'history' ||\n        (prevState && nextState && nextState.index === prevState.index)\n      ) {\n        return nextState;\n      }\n      let nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        const keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter((k) => k !== keyToAdd); // dedup\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        nextRouteKeyHistory.pop();\n      }\n      return {\n        ...nextState,\n        routeKeyHistory: nextRouteKeyHistory,\n      };\n    }\n\n    let nextState = possibleNextState;\n    if (\n      prevState &&\n      possibleNextState &&\n      prevState.index !== possibleNextState.index &&\n      resetOnBlur\n    ) {\n      const prevRouteName = prevState.routes[prevState.index].routeName;\n      const nextRoutes = [...possibleNextState.routes];\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = {\n        ...possibleNextState,\n        routes: nextRoutes,\n      };\n    }\n    return updateNextStateHistory(prevState, nextState);\n  }\n\n  function getInitialState() {\n    const routes = order.map(resetChildRoute);\n    const initialState = {\n      routes,\n      index: initialRouteIndex,\n    };\n\n    if (backBehavior === 'history') {\n      const initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n    return initialState;\n  }\n\n  return {\n    childRouters,\n\n    getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState } : inputState;\n      let state = inputState || getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map((route) => ({\n            ...route,\n            params: {\n              ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName\n                ? initialRouteParams\n                : null),\n            },\n          }));\n        }\n      }\n\n      if (\n        action.type === SwitchActions.JUMP_TO &&\n        (action.key == null || action.key === state.key)\n      ) {\n        const { params } = action;\n        const index = state.routes.findIndex(\n          (route) => route.routeName === action.routeName\n        );\n\n        if (index === -1) {\n          throw new Error(\n            `There is no route named '${action.routeName}' in the navigator with the key '${action.key}'.\\n` +\n              `Must be one of: ${state.routes\n                .map((route) => `'${route.routeName}'`)\n                .join(',')}`\n          );\n        }\n\n        return getNextState(action, prevState, {\n          ...state,\n          routes: params\n            ? state.routes.map((route, i) =>\n                i === index\n                  ? {\n                      ...route,\n                      params: {\n                        ...route.params,\n                        ...params,\n                      },\n                    }\n                  : route\n              )\n            : state.routes,\n          index,\n        });\n      }\n\n      // Let the current child handle it\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(\n          action,\n          activeChildLastState\n        );\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n      const isBackEligible =\n        action.key == null || action.key === activeChildLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        }\n        // The history contains current route, so we can only go back\n        // if there is more than one item in the history\n        else if (\n          isBackEligible &&\n          backBehavior === 'history' &&\n          state.routeKeyHistory.length > 1\n        ) {\n          const routeKey =\n            state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        }\n      }\n\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState = childState;\n\n          if (action.action && childRouter) {\n            const childStateUpdate = childRouter.getStateForAction(\n              action.action,\n              childState\n            );\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = {\n              ...newChildState,\n              params: {\n                ...(newChildState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            const nextState = {\n              ...state,\n              routes,\n              index: activeChildIndex,\n            };\n            return getNextState(action, prevState, nextState);\n          } else if (\n            newChildState === childState &&\n            state.index === activeChildIndex &&\n            prevState\n          ) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find((route) => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, {\n          ...state,\n          index: activeChildIndex,\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return { ...state };\n      }\n\n      const isActionBackOrPop =\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP ||\n        action.type === StackActions.POP_TO_TOP;\n      const sendActionToInactiveChildren =\n        !isActionBackOrPop ||\n        (action.type === NavigationActions.BACK && action.key != null);\n\n      // Let other children handle it and switch to the first child that returns a new state\n      // Do not do this for StackActions.POP or NavigationActions.BACK actions without a key:\n      // it would be unintuitive for these actions to switch to another tab just because that tab had a Stack that could accept a back action\n      if (sendActionToInactiveChildren) {\n        let index = state.index;\n        let routes = state.routes;\n        order.find((childId, i) => {\n          const childRouter = childRouters[childId];\n          if (i === index) {\n            return false;\n          }\n          let childState = routes[i];\n          if (childRouter) {\n            childState = childRouter.getStateForAction(action, childState);\n          }\n          if (!childState) {\n            index = i;\n            return true;\n          }\n          if (childState !== routes[i]) {\n            routes = [...routes];\n            routes[i] = childState;\n            index = i;\n            return true;\n          }\n          return false;\n        });\n\n        // Nested routers can be updated after switching children with actions such as SET_PARAMS\n        // and COMPLETE_TRANSITION.\n        if (action.preserveFocus) {\n          index = state.index;\n        }\n\n        if (index !== state.index || routes !== state.routes) {\n          return getNextState(action, prevState, {\n            ...state,\n            index,\n            routes,\n          });\n        }\n      }\n\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.defaultNavigationOptions\n    ),\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}